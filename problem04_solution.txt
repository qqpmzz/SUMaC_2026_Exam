Problem 4: p-Machine Solution
==============================

================================================================================
1. 조건
================================================================================

- p: 2보다 큰 소수 (prime, p > 2)
- k: 1 ≤ k ≤ p 인 양의 정수
- 디스플레이: {1, 2, 3, ..., p} 중 하나의 숫자
- 상자 색: 빨강(Red) 또는 검정(Black)


================================================================================
2. 연산 정의
================================================================================

[토글 스위치 (Toggle)]
- 빨강 → 검정, 또는 검정 → 빨강으로 색만 변경
- 숫자는 변하지 않음


[빨간색 크랭크 R(n)] - 1회 회전

조건                결과
-----------------   -----------------
n < p               n + 1
n = p               1

즉, 1씩 증가하며 p에서 1로 순환


[검은색 크랭크 B(n)] - 1회 회전

조건                결과
-----------------   -----------------
n ≤ p - k           n + k
n > p - k           n - (p - k)

즉, k씩 증가하며 p를 넘으면 p만큼 감소 (순환)


================================================================================
3. 수식 표현 (1 ~ p 범위)
================================================================================

R(n) = (n mod p) + 1

B(n) = ((n - 1 + k) mod p) + 1

검증 (p = 7, k = 3):
- R(6) = (6 mod 7) + 1 = 6 + 1 = 7  ✓
- R(7) = (7 mod 7) + 1 = 0 + 1 = 1  ✓
- B(4) = ((4 - 1 + 3) mod 7) + 1 = (6 mod 7) + 1 = 7  ✓
- B(5) = ((5 - 1 + 3) mod 7) + 1 = (7 mod 7) + 1 = 1  ✓


================================================================================
4. 0-based 변환 (0 ~ p-1 범위)
================================================================================

숫자 범위를 1~p에서 0~(p-1)로 변환하면 mod 연산이 더 깔끔해집니다.

변환: n' = n - 1  (즉, 1→0, 2→1, ..., p→p-1)


[변환된 빨간색 크랭크 R'(n)]

    R'(n) = (n + 1) mod p


[변환된 검은색 크랭크 B'(n)]

    B'(n) = (n + k) mod p


검증 (p = 7, k = 3, 0-based):
- R'(5) = (5 + 1) mod 7 = 6  ✓
- R'(6) = (6 + 1) mod 7 = 0  ✓
- B'(3) = (3 + 3) mod 7 = 6  ✓
- B'(4) = (4 + 3) mod 7 = 0  ✓


================================================================================
5. Successful 조건 정의
================================================================================

"program k is successful"의 정의:

임의의 서로 다른 두 숫자 i, j (1 ≤ i, j ≤ p)에 대해,
i가 디스플레이에 표시된 상태(빨강 또는 검정)에서 시작하여
크랭크를 여러 번 돌려서 j를 표시할 수 있다.

즉, 크랭크만으로 모든 숫자를 방문할 수 있어야 함.


================================================================================
6. Special 조건 정의
================================================================================

"program k is special"의 정의:

    Toggle → Crank(1회)  =  Crank(k회) → Toggle

즉, "토글 후 크랭크 1회"와 "크랭크 k회 후 토글"의 결과가
모든 시작 상태(색상, 숫자)에서 동일해야 함.


================================================================================
7. Part (a): Successful 조건 풀이
================================================================================

[빨간색에서 시작]

R'(n) = (n + 1) mod p

R'를 반복 적용하면:
- R'¹(n) = (n + 1) mod p
- R'²(n) = (n + 2) mod p
- ...
- R'ᵐ(n) = (n + m) mod p

m = 1, 2, ..., p-1 을 적용하면 n을 제외한 모든 숫자 방문 가능.
따라서 빨간색에서는 항상 Successful.


[검은색에서 시작]

B'(n) = (n + k) mod p

B'를 반복 적용하면:
- B'¹(n) = (n + k) mod p
- B'²(n) = (n + 2k) mod p
- ...
- B'ᵐ(n) = (n + mk) mod p

{mk mod p : m = 0, 1, 2, ...}가 생성하는 집합의 크기는:

    p / gcd(k, p)

모든 숫자(0 ~ p-1)를 방문하려면 이 크기가 p여야 함:

    p / gcd(k, p) = p
    gcd(k, p) = 1


[결론]

    Successful  ⟺  gcd(k, p) = 1

(p가 소수이므로, k ≠ p 일 때 gcd(k,p) = 1)


================================================================================
8. Part (b): Successful AND Special 조건 풀이
================================================================================

Special 조건을 분석합니다.

[빨간색에서 시작 (숫자 n)]

경로 1: Toggle → Crank(1회)
- Toggle: 빨강 → 검정
- Crank: B'(n) = (n + k) mod p
- 결과: (검정, n + k)

경로 2: Crank(k회) → Toggle
- Crank k회: R'ᵏ(n) = (n + k) mod p
- Toggle: 빨강 → 검정
- 결과: (검정, n + k)

비교: (n + k) = (n + k)  ⟹  항상 만족!


[검은색에서 시작 (숫자 n)]

경로 1: Toggle → Crank(1회)
- Toggle: 검정 → 빨강
- Crank: R'(n) = (n + 1) mod p
- 결과: (빨강, n + 1)

경로 2: Crank(k회) → Toggle
- Crank k회: B'ᵏ(n) = (n + k·k) mod p = (n + k²) mod p
- Toggle: 검정 → 빨강
- 결과: (빨강, n + k²)

비교: (n + 1) ≡ (n + k²) (mod p)

    1 ≡ k² (mod p)
    k² ≡ 1 (mod p)


[k² ≡ 1 (mod p)의 해]

k² - 1 ≡ 0 (mod p)
(k - 1)(k + 1) ≡ 0 (mod p)

p가 소수이므로:
- k - 1 ≡ 0 (mod p)  ⟹  k = 1
- k + 1 ≡ 0 (mod p)  ⟹  k = p - 1

1 ≤ k ≤ p 범위에서: k = 1 또는 k = p - 1


[Successful과 Special 동시 만족]

Special 조건: k = 1 또는 k = p - 1

Successful 조건 검증:
- k = 1: gcd(1, p) = 1  ✓
- k = p - 1: gcd(p-1, p) = 1  (연속한 두 정수는 서로소)  ✓


[결론]

    Successful AND Special  ⟺  k = 1 또는 k = p - 1


================================================================================
9. 최종 답
================================================================================

(a) Successful 조건:

    gcd(k, p) = 1

    p가 소수이므로, 이는 k ≠ p 와 동치.
    즉, 1 ≤ k ≤ p - 1


(b) Successful AND Special 조건:

    k = 1  또는  k = p - 1
